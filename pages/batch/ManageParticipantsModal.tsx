import React, { useState, useEffect } from 'react';
import { supabase } from '../../supabaseClient';
import { Profile, BatchParticipantWithProfile } from '../../types';
import { Button } from '../../components/ui/Button';

interface ManageParticipantsModalProps {
    batchId: string;
    existingParticipants: BatchParticipantWithProfile[];
    onClose: () => void;
    onSave: () => void;
}

const clusterOptions = ['N/A', 'Cluster A', 'Cluster B', 'Cluster C', 'Cluster D'];

export const ManageParticipantsModal: React.FC<ManageParticipantsModalProps> = ({ batchId, existingParticipants, onClose, onSave }) => {
    const [allProfiles, setAllProfiles] = useState<Profile[]>([]);
    const [participants, setParticipants] = useState<BatchParticipantWithProfile[]>(existingParticipants);
    const [loading, setLoading] = useState(true);
    const [saving, setSaving] = useState(false);
    const [searchTerm, setSearchTerm] = useState('');

    useEffect(() => {
        const fetchProfiles = async () => {
            setLoading(true);
            const { data, error } = await supabase.from('profiles').select('*').order('name');
            if (data) {
                setAllProfiles(data);
            }
            if (error) {
                console.error(error);
            }
            setLoading(false);
        };
        fetchProfiles();
    }, []);

    const handleAddParticipant = (profile: Profile) => {
        if (participants.some(p => p.participant_id === profile.id)) return; // Already exists

        // FIX: Add missing comment properties to satisfy the BatchParticipantWithProfile type.
        const newParticipant: BatchParticipantWithProfile = {
            id: '', // Will be generated by DB
            batch_id: batchId,
            participant_id: profile.id,
            created_at: new Date().toISOString(),
            overall_cluster: null,
            overall_comments: null,
            level_1_cluster: null,
            level_1_comments: null,
            level_2_cluster: null,
            level_2_comments: null,
            level_3_cluster: null,
            level_3_comments: null,
            level_4_cluster: null,
            level_4_comments: null,
            level_5_cluster: null,
            level_5_comments: null,
            profiles: profile
        };
        setParticipants([...participants, newParticipant]);
    };

    const handleRemoveParticipant = (participantId: string) => {
        setParticipants(participants.filter(p => p.participant_id !== participantId));
    };

    const handleClusterChange = (participantId: string, clusterType: keyof BatchParticipantWithProfile, value: string) => {
        setParticipants(participants.map(p =>
            p.participant_id === participantId
                ? { ...p, [clusterType]: value === 'N/A' ? null : value }
                : p
        ));
    };
    
    const handleSaveChanges = async () => {
        setSaving(true);
        
        // 1. Get participant IDs that should be in the batch
        const finalParticipantIds = participants.map(p => p.participant_id);

        // 2. Remove participants who are no longer in the list
        const { error: deleteError } = await supabase
            .from('batch_participants')
            .delete()
            .eq('batch_id', batchId)
            .not('participant_id', 'in', `(${finalParticipantIds.join(',')})`);
        
        if (deleteError) {
            alert(`Error removing participants: ${deleteError.message}`);
            setSaving(false);
            return;
        }

        // 3. Upsert current participants to add new ones and update clusters
        const upsertData = participants.map(p => ({
            batch_id: p.batch_id,
            participant_id: p.participant_id,
            overall_cluster: p.overall_cluster,
            level_1_cluster: p.level_1_cluster,
            level_2_cluster: p.level_2_cluster,
            level_3_cluster: p.level_3_cluster,
            level_4_cluster: p.level_4_cluster,
            level_5_cluster: p.level_5_cluster,
        }));
        
        const { error: upsertError } = await supabase
            .from('batch_participants')
            .upsert(upsertData, { onConflict: 'batch_id, participant_id' });

        if (upsertError) {
             alert(`Error saving participants: ${upsertError.message}`);
        } else {
            onSave();
        }

        setSaving(false);
    };

    const filteredProfiles = allProfiles.filter(p =>
        p.name.toLowerCase().includes(searchTerm.toLowerCase()) &&
        !participants.some(ep => ep.participant_id === p.id)
    );

    return (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4">
            <div className="bg-white dark:bg-gray-800 rounded-lg shadow-xl w-full max-w-4xl max-h-[90vh] flex flex-col">
                <div className="p-4 border-b dark:border-gray-700">
                    <h2 className="text-xl font-bold">Manage Participants & Clusters</h2>
                </div>

                <div className="p-4 flex-grow overflow-y-auto">
                    <div className="mb-4">
                        <label htmlFor="search-profiles" className="text-sm font-medium">Add Participant</label>
                        <input
                            id="search-profiles"
                            type="text"
                            placeholder="Search by name..."
                            value={searchTerm}
                            onChange={e => setSearchTerm(e.target.value)}
                            className="w-full mt-1 p-2 border rounded-md bg-gray-50 dark:bg-gray-700 dark:border-gray-600"
                        />
                        {searchTerm && (
                            <ul className="border dark:border-gray-600 rounded-md mt-1 max-h-40 overflow-y-auto">
                                {filteredProfiles.map(p => (
                                    <li key={p.id} className="p-2 hover:bg-gray-100 dark:hover:bg-gray-700 cursor-pointer" onClick={() => handleAddParticipant(p)}>
                                        {p.name}
                                    </li>
                                ))}
                            </ul>
                        )}
                    </div>
                    
                    <div className="overflow-x-auto">
                        <table className="min-w-full divide-y divide-gray-200 dark:divide-gray-700 text-sm">
                             <thead className="bg-gray-50 dark:bg-gray-700">
                                <tr>
                                    <th className="px-2 py-2 text-left font-medium">Name</th>
                                    <th className="px-2 py-2 text-left font-medium">Overall</th>
                                    <th className="px-2 py-2 text-left font-medium">Lvl 1</th>
                                    <th className="px-2 py-2 text-left font-medium">Lvl 2</th>
                                    <th className="px-2 py-2 text-left font-medium">Lvl 3</th>
                                    <th className="px-2 py-2 text-left font-medium">Lvl 4</th>
                                    <th className="px-2 py-2 text-left font-medium">Lvl 5</th>
                                    <th className="px-2 py-2 text-left font-medium"></th>
                                </tr>
                             </thead>
                             <tbody className="bg-white dark:bg-gray-800 divide-y divide-gray-200 dark:divide-gray-700">
                                {participants.map(p => (
                                    <tr key={p.participant_id}>
                                        <td className="px-2 py-2 whitespace-nowrap font-semibold">{p.profiles?.name}</td>
                                        {(['overall_cluster', 'level_1_cluster', 'level_2_cluster', 'level_3_cluster', 'level_4_cluster', 'level_5_cluster'] as const).map(key => (
                                            <td key={key} className="px-2 py-2">
                                                 <select value={p[key] || 'N/A'} onChange={e => handleClusterChange(p.participant_id, key, e.target.value)} className="w-24 p-1 border rounded bg-white dark:bg-gray-700 dark:border-gray-600">
                                                    {clusterOptions.map(opt => <option key={opt} value={opt}>{opt}</option>)}
                                                </select>
                                            </td>
                                        ))}
                                        <td className="px-2 py-2">
                                            <Button variant="danger-outline" size="sm" onClick={() => handleRemoveParticipant(p.participant_id)}>Remove</Button>
                                        </td>
                                    </tr>
                                ))}
                             </tbody>
                        </table>
                    </div>
                </div>

                <div className="p-4 border-t dark:border-gray-700 flex justify-end space-x-2">
                    <Button variant="secondary" onClick={onClose} disabled={saving}>Cancel</Button>
                    <Button onClick={handleSaveChanges} disabled={saving}>
                        {saving ? 'Saving...' : 'Save Changes'}
                    </Button>
                </div>
            </div>
        </div>
    );
};